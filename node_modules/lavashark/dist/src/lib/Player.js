"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RepeatMode = exports.ConnectionState = void 0;
const Node_1 = require("./Node");
const Queue_1 = require("./queue/Queue");
const UnresolvedTrack_1 = __importDefault(require("./queue/UnresolvedTrack"));
const Filters_1 = __importDefault(require("./Filters"));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["CONNECTING"] = 0] = "CONNECTING";
    ConnectionState[ConnectionState["CONNECTED"] = 1] = "CONNECTED";
    ConnectionState[ConnectionState["DISCONNECTED"] = 2] = "DISCONNECTED";
})(ConnectionState || (exports.ConnectionState = ConnectionState = {}));
/**
 * The queue repeat mode. This can be one of:
 * - OFF
 * - TRACK
 * - QUEUE
 */
var RepeatMode;
(function (RepeatMode) {
    RepeatMode[RepeatMode["OFF"] = 0] = "OFF";
    RepeatMode[RepeatMode["TRACK"] = 1] = "TRACK";
    RepeatMode[RepeatMode["QUEUE"] = 2] = "QUEUE";
})(RepeatMode || (exports.RepeatMode = RepeatMode = {}));
class Player {
    lavashark;
    node;
    guildId;
    filters;
    voiceChannelId;
    textChannelId;
    selfDeaf;
    selfMute;
    current;
    queue;
    repeatMode;
    position;
    positionTimestamp;
    playing;
    paused;
    state;
    voiceState;
    moving;
    static checkOptions(options) {
        if (!options.guildId)
            throw new TypeError('You must provide a guildId.');
        if (typeof options.guildId !== 'string')
            throw new TypeError('guildId must be a string.');
        if (!options.voiceChannelId)
            throw new TypeError('You must provide a voiceChannelId.');
        if (typeof options.voiceChannelId !== 'string')
            throw new TypeError('voiceChannelId must be a string.');
        if (options.textChannelId && typeof options.textChannelId !== 'string')
            throw new TypeError('textChannelId must be a string.');
        if (options.selfDeaf && typeof options.selfDeaf !== 'boolean')
            throw new TypeError('selfDeaf must be a boolean.');
        if (options.selfMute && typeof options.selfMute !== 'boolean')
            throw new TypeError('selfMute must be a boolean.');
        if (options.queue && !(options.queue instanceof Queue_1.Queue))
            throw new TypeError('Queue must extend Queue.');
    }
    /**
     * Create a new Player instance
     * @param {LavaShark} lavashark - The lavashark instance
     * @param {Object} options - The player options
     * @param {String} options.guildId - The guild id of this player
     * @param {String} options.voiceChannelId - The voice channel id of this player
     * @param {String} [options.textChannelId] - The text channel id of this player
     * @param {Boolean} [options.selfMute] - Whether or not this player is muted
     * @param {Boolean} [options.selfDeaf] - Whether or not this player is deafened
     * @param {Queue} [options.queue] - The queue for this player
     */
    constructor(lavashark, options) {
        Player.checkOptions(options);
        this.lavashark = lavashark;
        this.guildId = options.guildId;
        this.filters = new Filters_1.default(this);
        this.voiceChannelId = options.voiceChannelId;
        this.textChannelId = options.textChannelId ?? null;
        this.selfDeaf = options.selfDeaf ?? false;
        this.selfMute = options.selfMute ?? false;
        this.current = null;
        this.queue = options.queue ?? new Queue_1.Queue();
        this.repeatMode = RepeatMode.OFF;
        this.position = 0;
        this.positionTimestamp = 0;
        this.playing = false;
        this.paused = false;
        this.moving = false;
        this.state = ConnectionState.DISCONNECTED;
        this.voiceState = {};
        this.lavashark.emit('debug', `Player created for guild ${this.guildId}`);
        this.assignNode();
        this.lavashark.emit('playerCreate', this);
    }
    /**
     * Gets the exact track position based on the last playerUpdate packet
     */
    get exactPosition() {
        if (this.paused)
            return this.position;
        const filterConfig = this.filters.active.timescale;
        const rate = filterConfig?.rate ?? 1;
        const speed = filterConfig?.speed ?? 1;
        return Math.min(this.current?.duration.value ?? 0, (this.position + (Date.now() - this.positionTimestamp)) * rate * speed);
    }
    /**
     * Gets the queue duration in milliseconds
     * @deprecated - Use `queue.duration` instead
     */
    get queueDuration() {
        return this.queue.duration;
    }
    /**
     * Gets the volume of the player
     */
    get volume() {
        return (this.filters.active.volume ?? 100);
    }
    /**
     * Assigns a Node to this player
     * @private
     */
    async assignNode() {
        const node = await this.lavashark.bestNode();
        this.node = node;
        this.lavashark.emit('debug', `Assigned node ${node.identifier} to player ${this.guildId}`);
    }
    /**
     * Adds one or more tracks to the queue
     * @param {Track | UnresolvedTrack | Array<Track | UnresolvedTrack>} tracks - The track(s) to add to the queue
     * @param requester - The requester of the track(s)
     */
    addTracks(tracks, requester) {
        if (Array.isArray(tracks)) {
            for (const track of tracks) {
                track.setRequester(requester);
                this.queue.add(track);
            }
        }
        else {
            tracks.setRequester(requester);
            this.queue.add(tracks);
        }
        this.lavashark.emit('trackAdd', this, tracks);
    }
    /**
     * Connects to the voice channel
     */
    async connect() {
        if (this.state !== ConnectionState.DISCONNECTED) {
            return;
        }
        if (!this.voiceChannelId) {
            throw new Error('No voice channel id provided');
        }
        this.lavashark.emit('debug', `Connecting player ${this.guildId} to voice channel ${this.voiceChannelId}`);
        if (this.node === null) {
            await this.assignNode();
        }
        this.state = ConnectionState.CONNECTING;
        this.sendVoiceState();
        const maxChecks = 5;
        const checkInterval = 1000; // 1s
        const checkConnected = async () => {
            for (let i = 0; i < maxChecks; i++) {
                if (this.state === ConnectionState.CONNECTED) {
                    return;
                }
                else if (this.state === ConnectionState.DISCONNECTED) {
                    this.destroy();
                    throw new Error('Voice connection timeout.');
                }
                await new Promise(resolve => setTimeout(resolve, checkInterval));
            }
            this.state = ConnectionState.DISCONNECTED;
            this.destroy();
            throw new Error('Voice connection timeout.');
        };
        await checkConnected();
        this.lavashark.emit('playerConnect', this);
    }
    /**
     * Disconnects from the voice channel
     */
    disconnect() {
        this.lavashark.sendWS(this.guildId, {
            op: 4,
            d: {
                guild_id: this.guildId,
                channel_id: null
            }
        });
        this.voiceState = {};
        this.state = ConnectionState.DISCONNECTED;
        this.lavashark.emit('debug', `Player ${this.guildId} disconnected from voice channel`);
    }
    /**
     * Destroys the player
     */
    destroy() {
        this.disconnect();
        this.node?.rest.destroyPlayer(this.guildId)
            .catch((_error) => {
            this.lavashark.emit('error', this.node, `Failed to send destroyPlayer signal to node "${this.node?.identifier}"`);
        });
        this.node = null;
        this.lavashark.players.delete(this.guildId);
        this.lavashark.emit('playerDestroy', this);
        this.lavashark.emit('debug', `Player ${this.guildId} destroyed`);
    }
    /**
     * @param {Node} node - The target node to move the player
     */
    async moveNode(node) {
        if (!node)
            throw new TypeError('You must provide a Node instance.');
        if (node.state !== Node_1.NodeState.CONNECTED)
            throw new Error('The provided node is not connected.');
        if (this.node === node)
            return;
        this.lavashark.emit('debug', `Moving player ${this.guildId} from node ${this.node?.identifier ?? 'None'} to node ${node.identifier}`);
        this.moving = true;
        await this.node?.rest.destroyPlayer(this.guildId);
        this.node = node;
        if (Object.keys(this.voiceState).length === 2) {
            this.state = ConnectionState.CONNECTING;
            await this.sendVoiceUpdate();
        }
        if (this.filters.enabled) {
            this.filters.apply();
        }
        if (this.playing && this.current) {
            await this.node.rest.updatePlayer(this.guildId, {
                encodedTrack: this.current.encodedTrack,
                position: this.current.isStream ? 0 : this.position
            });
        }
        else {
            this.moving = false;
        }
    }
    /**
     * Gets the latency between lavalink client & node
     * @returns {Promise<Number>} - In milliseconds
     */
    async ping() {
        if (this.node === null || this.state !== ConnectionState.CONNECTED)
            return -1;
        try {
            const startTime = Date.now();
            await this.node.getVersion();
            const endTime = Date.now();
            const ping = endTime - startTime;
            return ping;
        }
        catch (_) {
            return -1;
        }
    }
    /**
     * Plays a track
     * @param {Object} [options] - Play options
     * @param {Number} [options.startTime] - Start time in milliseconds
     * @param {Number} [options.endTime] - End time in milliseconds
     * @param {Boolean} [options.noReplace] - Whether to ignore operation if a track is already playing or paused
     */
    async play(options) {
        if (this.node === null) {
            await this.assignNode();
        }
        if (!this.current) {
            let newTrack = this.queue.poll();
            if (newTrack) {
                if (newTrack instanceof UnresolvedTrack_1.default) {
                    try {
                        newTrack = await newTrack.build();
                    }
                    catch (e) {
                        this.lavashark.emit('trackException', this, newTrack, e);
                        if (this.queue.size > 0)
                            this.play();
                        return;
                    }
                }
            }
            else {
                throw new Error('The queue is empty!');
            }
            this.current = newTrack;
        }
        await this.node?.rest.updatePlayer(this.guildId, {
            encodedTrack: this.current.encodedTrack,
            position: options?.startTime ?? 0,
            ...options
        });
        this.playing = true;
    }
    /**
     * Pause or unpause the player
     * @param {Boolean} [state=true] - Whether to pause or unpause the player
     */
    async pause(state = true) {
        if (typeof state !== 'boolean') {
            throw new TypeError('State must be a boolean');
        }
        if (this.node === null)
            throw new Error('Assertion failed. The player does not have a node.');
        if (!this.playing)
            return false;
        this.paused = state;
        await this.node.rest.updatePlayer(this.guildId, {
            paused: state
        });
        return true;
    }
    /**
     * Resume the player
     */
    async resume() {
        return await this.pause(false);
    }
    /**
     * Skips the current playing track
     * @param {Number} [amount=1] - The amount of tracks to skip
     */
    async skip(amount) {
        if (typeof amount === 'undefined')
            amount = 1;
        if (typeof amount !== 'number')
            TypeError('Amount must be a number');
        if (!this.playing)
            return false;
        if (amount > this.queue.size) {
            this.queue.clear();
        }
        else {
            this.queue.skipNTracks(amount);
        }
        try {
            await this.node?.rest.updatePlayer(this.guildId, {
                encodedTrack: null
            });
            return true;
        }
        catch (_) {
            return false;
        }
    }
    /**
     * Seek to a specific position in the track
     * @param {Number} position - The position to seek, in milliseconds
     */
    async seek(position) {
        if (!this.playing || !this.current || !this.current.isSeekable)
            return;
        if (typeof position !== 'number') {
            throw new TypeError('Position must be a number');
        }
        if (position > this.current.duration.value) {
            await this.skip();
            return;
        }
        await this.node?.rest.updatePlayer(this.guildId, {
            position
        });
    }
    /**
     * Set repeat mode for this queue
     * @param {RepeatMode} mode - The repeat mode to apply
     */
    setRepeatMode(mode) {
        switch (mode) {
            case RepeatMode.OFF: {
                this.repeatMode = RepeatMode.OFF;
                break;
            }
            case RepeatMode.TRACK: {
                this.repeatMode = RepeatMode.TRACK;
                break;
            }
            case RepeatMode.QUEUE: {
                this.repeatMode = RepeatMode.QUEUE;
                break;
            }
            default: {
                throw new TypeError('Invalid RepeatMode parameter.');
            }
        }
    }
    /**
     * Sends a voice state update payload to the discord gateway
     * @private
     */
    sendVoiceState() {
        this.lavashark.sendWS(this.guildId, {
            op: 4,
            d: {
                guild_id: this.guildId,
                channel_id: this.voiceChannelId,
                self_mute: this.selfMute,
                self_deaf: this.selfDeaf
            }
        });
        this.lavashark.emit('debug', `Sent voiceStateUpdate to discord gateway for player ${this.guildId}. Channel: ${this.voiceChannelId}. Self mute: ${this.selfMute}. Self deaf: ${this.selfDeaf}`);
    }
    /**
     * Sets the bot's self deaf state
     * @param state - Whether to self deaf or not
     */
    setSelfDeaf(state) {
        if (typeof state !== 'boolean')
            throw new TypeError('state must be a boolean');
        if (this.selfDeaf !== state && this.state !== ConnectionState.DISCONNECTED) {
            this.selfDeaf = state;
            this.sendVoiceState();
        }
    }
    /**
     * Sets the bot's self mute state
     * @param {Boolean} state - Whether to self mute or not
     */
    setSelfMute(state) {
        if (typeof state !== 'boolean')
            throw new TypeError('state must be a boolean');
        if (this.selfMute !== state && this.state !== ConnectionState.DISCONNECTED) {
            this.selfMute = state;
            this.sendVoiceState();
        }
    }
    /**
     * Sets the player voice channel
     * @param {String} channelId - The voice channel id
     */
    setVoiceChannel(channelId) {
        if (!channelId || typeof channelId !== 'string')
            throw new TypeError('Voice channel id must be a string.');
        if (this.voiceChannelId === channelId)
            return;
        this.voiceChannelId = channelId;
        this.state = ConnectionState.DISCONNECTED;
        this.connect();
    }
    async sendVoiceUpdate() {
        if (this.node === null) {
            await this.assignNode();
        }
        this.state = ConnectionState.CONNECTED;
        await this.node?.rest.updatePlayer(this.guildId, {
            voice: {
                sessionId: this.voiceState.sessionId,
                token: this.voiceState.event.token,
                endpoint: this.voiceState.event.endpoint
            }
        });
        this.lavashark.emit('debug', `Sent voiceUpdate to lavalink node for player ${this.guildId}.`);
    }
    /**
     * Update player state
     * @inner
     * @param state - playerUpdate event
     */
    update(state) {
        if ('position' in state) {
            this.position = state.position ?? 0;
        }
        if ('time' in state) {
            this.positionTimestamp = state.time;
        }
        if ('connected' in state) {
            if (state.connected) {
                this.state = ConnectionState.CONNECTED;
            }
            else {
                this.state = ConnectionState.DISCONNECTED;
            }
        }
    }
}
exports.default = Player;

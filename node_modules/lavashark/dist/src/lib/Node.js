"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeState = void 0;
const promises_1 = require("timers/promises");
const ws_1 = __importDefault(require("ws"));
const Player_1 = require("./Player");
const RESTController_1 = require("./rest/RESTController");
const RESTPaths_1 = require("./rest/RESTPaths");
const UnresolvedTrack_1 = __importDefault(require("./queue/UnresolvedTrack"));
const generateRandomKey_1 = require("./utils/generateRandomKey");
const index_1 = require("../index");
var NodeState;
(function (NodeState) {
    NodeState[NodeState["CONNECTING"] = 0] = "CONNECTING";
    NodeState[NodeState["CONNECTED"] = 1] = "CONNECTED";
    NodeState[NodeState["DISCONNECTED"] = 2] = "DISCONNECTED";
})(NodeState || (exports.NodeState = NodeState = {}));
class Node {
    lavashark;
    options;
    packetQueue;
    rest;
    resumeKey;
    retryAttempts;
    state;
    stats;
    keepAliveInterval;
    static checkOptions(options) {
        if (typeof options !== 'object') {
            throw new TypeError('NodeOptions must be an object');
        }
        if (!options.hostname) {
            throw new TypeError('NodeOptions.hostname is required');
        }
        if (!options.port) {
            throw new TypeError('NodeOptions.port is required');
        }
        if (typeof options.hostname !== 'string') {
            throw new TypeError('NodeOptions.hostname must be a string');
        }
        if (typeof options.port !== 'number') {
            throw new TypeError('NodeOptions.port must be a number');
        }
        if (options.id && typeof options.id !== 'string') {
            throw new TypeError('NodeOptions.id must be a string');
        }
        if (options.password && typeof options.password !== 'string') {
            throw new TypeError('NodeOptions.password must be a string');
        }
        if (options.resumeKey && typeof options.resumeKey !== 'string') {
            throw new TypeError('NodeOptions.resumeKey must be a string');
        }
        if (options.resumeTimeout && typeof options.resumeTimeout !== 'number') {
            throw new TypeError('NodeOptions.resumeTimeout must be a number');
        }
        if (options.secure && typeof options.secure !== 'boolean') {
            throw new TypeError('NodeOptions.secure must be a boolean');
        }
        if (options.followRedirects && typeof options.followRedirects !== 'boolean') {
            throw new TypeError('NodeOptions.followRedirects must be a boolean');
        }
        if (options.maxRetryAttempts && typeof options.maxRetryAttempts !== 'number') {
            throw new TypeError('NodeOptions.maxRetryAttempts must be a number');
        }
        if (options.retryAttemptsInterval && typeof options.retryAttemptsInterval !== 'number') {
            throw new TypeError('NodeOptions.retryAttemptsInterval must be a number');
        }
    }
    /**
     * Create a new Node instance
     * @param {LavaShark} lavashark - The LavaShark instance
     * @param {Object} options - The node options
     * @param {String} [options.id] - The lavalink node identifier
     * @param {String} options.hostname - The lavalink node hostname
     * @param {Number} options.port - The lavalink node port
     * @param {String} [options.password] - The lavalink node password
     * @param {Boolean} [options.secure] - Whether the lavalink node uses TLS/SSL or not
     * @param {String} [options.region] - The lavalink node region
     * @param {String} [options.resumeKey] - The resume key
     * @param {Number} [options.resumeTimeout] - The resume timeout, in seconds
     * @param {Number} [options.maxRetryAttempts] - The max number of reconnect attempts
     * @param {Number} [options.retryAttemptsInterval] - The interval between reconnect attempts, in milliseconds
     * @param {Boolean} [options.followRedirects] - Whether to follow redirects (3xx status codes)
     * @param {Boolean} [options.sendSpeakingEvents=false] - Tells the lavalink node to send speaking events (Supported in my custom lavalink fork)
     */
    constructor(lavashark, options) {
        Node.checkOptions(options);
        this.lavashark = lavashark;
        this.options = options;
        this.retryAttempts = 0;
        this.state = NodeState.DISCONNECTED;
        this.stats = {
            playingPlayers: 0,
            players: 0,
            uptime: 0,
            memory: {
                reservable: 0,
                used: 0,
                free: 0,
                allocated: 0,
            },
            cpu: {
                cores: 0,
                systemLoad: 0,
                lavalinkLoad: 0,
            },
            frameStats: {
                sent: 0,
                nulled: 0,
                deficit: 0,
            }
        };
        this.packetQueue = [];
        this.rest = new RESTController_1.RESTController(this);
        this.ws = null;
    }
    get identifier() {
        return this.options.id ?? this.options.hostname;
    }
    get totalPenalties() {
        if (this.state !== NodeState.CONNECTED || !this.ws) {
            return Infinity;
        }
        else {
            return this.penalties ?? 0;
        }
    }
    calcPenalties() {
        const totalWeight = 100; // Total weight is 100%
        // Weights for each penalty category
        const weightCpuPenalty = 25;
        const weightDeficitFramePenalty = 30;
        const weightNullFramePenalty = 15;
        const weightPlayingPlayers = 30;
        const cpuPenalty = Math.pow(1.05, 100 * this.stats.cpu.systemLoad) * 10 - 10;
        let deficitFramePenalty = 0, nullFramePenalty = 0;
        if (this.stats.frameStats) {
            deficitFramePenalty = Math.pow(1.03, this.stats.frameStats.deficit * 2);
            nullFramePenalty = Math.pow(1.03, this.stats.frameStats.nulled);
        }
        // Calculate weighted values for each penalty category
        const weightedPlayingPlayers = (weightPlayingPlayers / totalWeight) * this.stats.playingPlayers;
        const weightedDeficitFramePenalty = (weightDeficitFramePenalty / totalWeight) * deficitFramePenalty;
        const weightedNullFramePenalty = (weightNullFramePenalty / totalWeight) * nullFramePenalty;
        const weightedCpuPenalty = (weightCpuPenalty / totalWeight) * cpuPenalty;
        this.penalties = ~~((weightedPlayingPlayers + weightedDeficitFramePenalty + weightedNullFramePenalty + weightedCpuPenalty) * 100);
    }
    /**
     * Connect to node
     */
    connect() {
        if (this.state !== NodeState.DISCONNECTED)
            return;
        ++this.retryAttempts;
        this.state = NodeState.CONNECTING;
        const headers = {
            'User-Id': this.lavashark.clientId,
            'Client-Name': `LavaShark/${index_1.VERSION}`,
            Authorization: this.options.password ?? 'youshallnotpass'
        };
        if (this.options.resumeKey !== 'disable' && this.options.resumeKey !== 'DISABLE') {
            this.resumeKey = `LavaShark_${index_1.VERSION}_${(0, generateRandomKey_1.generateRandomKey)(8)}`;
            Object.assign(headers, { 'Resume-Key': this.resumeKey });
        }
        const wsUrl = `ws${this.options.secure ? 's' : ''}://${this.options.hostname}:${this.options.port}/v${RESTPaths_1.API_VERSION}/websocket`;
        this.ws = new ws_1.default(wsUrl, {
            headers,
            followRedirects: this.options.followRedirects
        });
        this.ws.onopen = this.open.bind(this);
        this.ws.onmessage = this.message.bind(this);
        this.ws.onerror = this.error.bind(this);
        this.ws.onclose = this.close.bind(this);
        this.ws.on('upgrade', this.upgrade.bind(this));
        this.ws.on('pong', this.pong.bind(this));
    }
    /**
     * Disconnect from node
     */
    disconnect() {
        if (this.ws !== null)
            this.ws.close(1000, 'LavaShark: disconnect');
    }
    /**
     * Reconnects the node
     */
    async reconnect() {
        this.disconnect();
        await (0, promises_1.setTimeout)(50);
        this.connect();
        await (0, promises_1.setTimeout)(2000);
    }
    /**
     * Check session exists
     */
    async checkNodeSession() {
        try {
            await this.rest.updateSession(this.resumeKey, this.options.resumeTimeout ?? 60);
        }
        catch (_) {
            this.lavashark.emit('error', this, `Updating session failed, try to reconnect node "${this.options.id}"`);
            await this.reconnect();
        }
    }
    KeepingNodeAwake(milliseconds) {
        this.keepAliveInterval = setInterval(async () => {
            try {
                this.ws?.ping();
            }
            catch (error) {
                this.lavashark.emit('error', this, `Keeping node awake failed, try to reconnect node "${this.options.id}"`);
                await this.reconnect();
            }
        }, milliseconds);
    }
    stopKeepingNodeAwake() {
        clearInterval(this.keepAliveInterval);
    }
    /**
     * Get the Lavalink Node version
     * @returns {Promise<version>}
     */
    async getVersion() {
        const version = (await this.rest.version()).toString();
        this.version = version;
        return version;
    }
    /**
     * Get the Lavalink Node information
     * @returns {Promise<Info>}
     */
    async getInfo() {
        const info = await this.rest.info();
        return info;
    }
    /**
     * Get the Lavalink Node stats
     * @returns {Promise<NodeStats>}
     */
    async getStats() {
        const stats = await this.rest.stats();
        this.stats = stats;
        return stats;
    }
    /**
     * Get the ping for the node
     * @param {number} timeout - Timeout value in milliseconds
     * @returns {Promise<number>} - Node latency, in milliseconds
     */
    async getPing(timeout = 1500) {
        try {
            const startTime = Date.now();
            await Promise.race([
                this.getStats(),
                new Promise((_, reject) => {
                    setTimeout(() => {
                        reject(new Error('Update stats timed out'));
                    }, timeout);
                })
            ]);
            const endTime = Date.now();
            const ping = endTime - startTime;
            return ping;
        }
        catch (_) {
            this.disconnect();
            this.lavashark.emit('error', this, new Error(`An error occurred while updating stats: Unable to connect to the node`));
            return -1;
        }
    }
    /**
     * Gets the route planner status
     * @returns {Promise<Object>}
     */
    getRoutePlannerStatus() {
        return this.rest.getRoutePlannerStatus();
    }
    /**
     * Unmarks a failed address
     * @param {String} address - The address to unmark
     */
    unmarkFailedAddress(address) {
        return this.rest.freeRoutePlannerAddress(address);
    }
    /**
     * Unmarks all failed address
     */
    unmarkAllFailedAddress() {
        return this.rest.freeAllRoutePlannerAddresses();
    }
    /**
     * Update node stats
     */
    async updateStats(timeout = 1500) {
        try {
            await Promise.race([
                this.getStats(),
                new Promise((_, reject) => {
                    setTimeout(() => {
                        reject(new Error('Update stats timed out'));
                    }, timeout);
                })
            ]);
            this.calcPenalties();
        }
        catch (_) {
            this.disconnect();
            this.lavashark.emit('error', this, new Error(`An error occurred while updating stats: Unable to connect to the node "${this.identifier}"`));
        }
    }
    async pollTrack(player) {
        let newTrack = player.queue.poll();
        if (newTrack) {
            if (newTrack instanceof UnresolvedTrack_1.default) {
                try {
                    newTrack = await newTrack.build();
                }
                catch (err) {
                    this.lavashark.emit('trackException', player, newTrack, err);
                    this.pollTrack(player);
                    return;
                }
            }
            player.current = newTrack;
            player.play();
            return;
        }
        player.current = null;
        this.lavashark.emit('queueEnd', player);
    }
    handlePlayerEvent(e) {
        const player = this.lavashark.players.get(e.guildId);
        if (!player || player.node !== this)
            return;
        switch (e.type) {
            case 'TrackStartEvent': {
                this.handleTrackStart(e, player);
                break;
            }
            case 'TrackEndEvent': {
                this.handleTrackEnd(e, player);
                break;
            }
            case 'TrackStuckEvent': {
                this.handleTrackStuck(e, player);
                break;
            }
            case 'TrackExceptionEvent': {
                this.handleTrackException(e, player);
                break;
            }
            case 'WebSocketClosedEvent': {
                this.handleWSClose(e, player);
                break;
            }
            default: {
                this.lavashark.emit('warn', this, `Unhandled player event. Unknown event type: ${e.type}`);
                break;
            }
        }
    }
    handleTrackStart(_, player) {
        player.playing = true;
        player.paused = false;
        if (player.moving) {
            player.moving = false;
            return;
        }
        this.lavashark.emit('trackStart', player, player.current);
    }
    handleTrackEnd(ev, player) {
        if (ev.reason === 'REPLACED') {
            if (player.repeatMode === Player_1.RepeatMode.QUEUE && player.current) {
                player.queue.add(player.current);
            }
            return;
        }
        player.playing = false;
        if (['LOAD_FAILED', 'CLEANUP'].includes(ev.reason)) {
            this.lavashark.emit('trackEnd', player, player.current, ev.reason);
            this.pollTrack(player);
            return;
        }
        this.lavashark.emit('trackEnd', player, player.current, ev.reason);
        if (player.repeatMode === Player_1.RepeatMode.TRACK) {
            player.play();
            return;
        }
        if (player.repeatMode === Player_1.RepeatMode.QUEUE && player.current) {
            player.queue.add(player.current);
        }
        this.pollTrack(player);
    }
    handleTrackStuck(ev, player) {
        this.lavashark.emit('trackStuck', player, player.current, ev.thresholdMs);
    }
    handleTrackException(ev, player) {
        this.lavashark.emit('trackException', player, player.current, ev.exception);
        player.skip();
    }
    handleWSClose(ev, player) {
        this.lavashark.emit('playerDisconnect', player, ev.code, ev.reason);
        switch (ev.code) {
            case 1001:
            case 1006:
            case 4015:
                player.sendVoiceUpdate();
                break;
            case 4006:
            case 4009:
                player.state = Player_1.ConnectionState.DISCONNECTED;
                player.connect();
                break;
        }
    }
    // ---------- WebSocket event handlers ----------
    open() {
        this.state = NodeState.CONNECTED;
        this.lavashark.emit('nodeConnect', this);
        this.retryAttempts = 0;
        this.KeepingNodeAwake(30 * 1000);
        for (let i = 0; i < this.packetQueue.length; i++) {
            if (this.state !== NodeState.CONNECTED)
                break;
            const packet = this.packetQueue.shift();
            if (packet)
                this.ws?.send(packet);
        }
    }
    message({ data }) {
        const payload = JSON.parse(data);
        switch (payload.op) {
            case 'ready': {
                this.rest.setSessionId = payload.sessionId;
                break;
            }
            case 'stats': {
                delete payload.op;
                this.stats = payload;
                this.calcPenalties();
                this.lavashark.emit('debug', `Node "${this.identifier}" penalties: ${this.totalPenalties}`);
                break;
            }
            case 'playerUpdate': {
                this.lavashark.players.get(payload.guildId)?.update(payload.state);
                break;
            }
            case 'event': {
                this.handlePlayerEvent(payload);
                break;
            }
            default: {
                this.lavashark.emit('warn', this, 'Unknown payload op: ' + payload.op);
                break;
            }
        }
        this.lavashark.emit('raw', this, payload);
    }
    error({ error, message }) {
        if (message.includes('connect ECONNREFUSED'))
            return;
        if (message.includes('401')) {
            this.retryAttempts = Infinity;
            this.lavashark.emit('error', this, new Error('Authentication failed!'));
            return;
        }
        this.lavashark.emit('error', this, error);
    }
    async close({ code, reason, wasClean }) {
        this.state = NodeState.DISCONNECTED;
        this.stopKeepingNodeAwake();
        this.ws?.removeAllListeners();
        this.ws = null;
        if (wasClean) {
            this.lavashark.emit('nodeDisconnect', this, code, reason);
            return;
        }
        try {
            const newNode = await this.lavashark.bestNode();
            if (newNode) {
                for (const player of this.lavashark.players.values()) {
                    if (player.node === this) {
                        await player.moveNode(newNode);
                    }
                }
            }
        }
        catch (_) {
            // no available nodes, so we can't move the players
        }
        this.lavashark.emit('error', this, new Error(`WebSocket closed abnormally with code ${code}.`));
        if (this.retryAttempts > (this.options.maxRetryAttempts ?? 10))
            return;
        if (this.retryAttempts === 0)
            this.connect();
        else
            setTimeout(() => this.connect(), this.options.retryAttemptsInterval ?? 5000);
    }
    upgrade(msg) {
        if (msg.headers['session-resumed'] === 'true') {
            this.lavashark.emit('nodeResume', this);
        }
    }
    pong(data) {
        this.lavashark.emit('pong', this, data);
    }
}
exports.default = Node;

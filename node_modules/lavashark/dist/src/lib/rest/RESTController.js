"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RESTController = void 0;
const undici_1 = require("undici");
const RESTPaths_1 = require("./RESTPaths");
class RESTController {
    node;
    restUrl;
    _sessionId;
    set setSessionId(sessionId) {
        this._sessionId = sessionId;
    }
    constructor(node) {
        this.node = node;
        this.restUrl = `http${node.options.secure ? 's' : ''}://${node.options.hostname}:${node.options.port}`;
    }
    async decodeTrack(encodedTrack) {
        return this.request({
            method: 'GET',
            path: (0, RESTPaths_1.DECODE_TRACKS)() + `?track=${encodeURIComponent(encodedTrack)}`
        });
    }
    async decodeTracks(encodedTracks) {
        return this.request({
            method: 'POST',
            path: (0, RESTPaths_1.DECODE_TRACKS)(),
            json: encodedTracks
        });
    }
    async getRoutePlannerStatus() {
        return this.request({
            method: 'GET',
            path: (0, RESTPaths_1.ROUTE_PLANNER_STATUS)()
        });
    }
    async freeRoutePlannerAddress(address) {
        await this.request({
            method: 'POST',
            path: (0, RESTPaths_1.ROUTE_PLANNER_FREE_ADDR)(),
            json: {
                address
            }
        });
    }
    async freeAllRoutePlannerAddresses() {
        await this.request({
            method: 'POST',
            path: (0, RESTPaths_1.ROUTE_PLANNER_FREE_ALL)()
        });
    }
    async loadTracks(identifier) {
        return this.request({
            method: 'GET',
            path: (0, RESTPaths_1.LOAD_TRACKS)(identifier)
        });
    }
    async updateSession(resumeKey, timeout) {
        await this.request({
            method: 'PATCH',
            path: (0, RESTPaths_1.SESSIONS)(this._sessionId),
            json: {
                resumeKey,
                timeout
            }
        });
    }
    async destroyPlayer(guildId) {
        await this.request({
            method: 'DELETE',
            path: (0, RESTPaths_1.PLAYER)(this._sessionId, guildId)
        });
    }
    async updatePlayer(guildId, options) {
        let path = (0, RESTPaths_1.PLAYER)(this._sessionId, guildId);
        if (options.noReplace) {
            path += '?noReplace=true';
        }
        delete options.noReplace;
        await this.request({
            method: 'PATCH',
            path,
            json: options
        });
    }
    async version() {
        return this.request({
            method: 'GET',
            path: (0, RESTPaths_1.VERSION)(),
        });
    }
    async info() {
        return this.request({
            method: 'GET',
            path: (0, RESTPaths_1.INFO)()
        });
    }
    async stats() {
        return this.request({
            method: 'GET',
            path: (0, RESTPaths_1.STATS)(),
        });
    }
    async request(options) {
        const { method, path, json } = options;
        const headers = {
            ...options.headers,
            'authorization': this.node.options.password ?? 'youshallnotpass',
        };
        let body = null;
        if (json) {
            headers['Content-Type'] = 'application/json';
            body = JSON.stringify(json);
        }
        const res = await (0, undici_1.fetch)(`${this.restUrl}${path}`, {
            method,
            headers,
            body
        });
        if (res.status >= 400) {
            if (res.headers.get('content-type') === 'application/json') {
                const error = await res.json();
                throw new Error(`Lavalink request failed with status code ${res.status}. Path: ${error.path}. ERROR: ${error.error}: ${error.message}`);
            }
            throw new Error(`Request failed with status code ${res.status}`);
        }
        let resBody;
        if (res.status === 204) {
            resBody = null;
        }
        else if (res.headers.get('content-type') === 'application/json') {
            resBody = await res.json();
        }
        else {
            resBody = Buffer.from(await res.arrayBuffer());
        }
        return resBody;
    }
}
exports.RESTController = RESTController;
